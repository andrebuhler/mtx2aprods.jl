
 \documentclass[12pt,a4paper]{article}
 \usepackage[utf8]{inputenc}
 \usepackage[portuguese]{babel}
 %----------------------------------------------------
 %\usepackage[Algoritmo]{algorithm,algorithmic}
 \usepackage[portuguese, ruled, linesnumbered]{algorithm2e}

 \usepackage{graphicx}
 \usepackage{enumerate}
 %\usepackage{algorithm,algorithmic}
 \usepackage{listings}
 \usepackage{subfig}
 \usepackage[dvipsnames]{xcolor}
 \usepackage{fancyvrb}

 \newtheorem{teorema}{Teorema}     
 \newtheorem{definicao}{Definição}
 \usepackage{threeparttable}
 \usepackage{setspace}
 \usepackage{float}

 \usepackage[style=ieee,backend=bibtex,sorting=none]{biblatex}
 \DefineBibliographyStrings{portuguese}{
   references = {Bibliografia},
 }
 \addbibresource{refs.bib}

 % Um pacote de comandos auxiliares
 \usepackage{auxiliares}
 \usepackage{amsmath, amsfonts, bbm, amssymb, amsthm}
 \usepackage{lmodern}
 \renewcommand{\rmdefault}{phv} % Arial
 \renewcommand{\sfdefault}{phv} % Arial
 \usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
 \usepackage{authblk}
 \usepackage{textcomp}
 \setlength{\affilsep}{0mm}
 \newcommand\SLASH{\char`\\}



 \date{}
 \begin{document}

 \maketitle
        
     \section{3.4}

 
 Para aproveitar o grande número de elementos zero, são necessários esquemas especiais para armazenar matrizes esparsas.
     O objetivo principal é representar apenas os elementos não nulos e ser capaz de executar as operações de matriz comuns.
     
     No seguinte, N z indica o número total de elementos diferentes de zero.
     O esquema de armazenamento mais simples para matrizes dispersas é o chamado formato de coordenadas.
     A estrutura de dados consiste em três arrays:
     \begin{itemize} 
     \item Uma matriz real contendo todos os valores reais (ou complexos) dos elementos diferentes de zero de A em qualquer ordem;
     \item Uma matriz de inteiros contendo seus índices de linha;
     \item Uma segunda matriz de inteiros contendo seus índices de colunas.
     \end{itemize}
     Todos os três arrays são de comprimento N z, o número de elementos não nulos.

 %matriz exemplo 3.7
 A= 1 &  0 &  0 &  2 &  0 \\
3 &  4 &  0 &  5 &  0\\
6 &  0 &  7 &  8 &  9  \\ 
0 &  0 &  10 &  11 &  0\\
0 &  0 &  0 &  0 &  12\\
 %vetor AA JR JC
 
 No exemplo acima, os elementos são listados em uma ordem arbitrária.
Na verdade, elas geralmente são listadas por linhas ou colunas.
Se os elementos foram listados por linha, a matriz JC que contém informações redundantes pode ser substituída por uma matriz que aponta para o início de cada linha.
  Isto implicaria economias não negligenciáveis no armazenamento. A nova estrutura de dados tem três matrizes com as seguintes funções:
 \begin{itemize}   

  \item  Um array real AA contém os valores reais a ij armazenados linha por linha, da linha 1 a n.
   O comprimento de AA é N z.
 \item  Uma matriz de inteiro JA contém os índices de coluna dos elementos a ij armazenados na matriz AA.
  O comprimento de JA é Nz.
 \item  Uma matriz de inteiros IA contém os ponteiros para o início de cada linha nos arrays AA e JA.
 \end{itemize}
  Deste modo, o conteúdo de IA (i) é a posição nas matrizes AA e JA onde começa a linha i-ésima.
  O comprimento de IA é n + 1 com IA (n + 1) contendo o número IA (1) + N z, ou seja, o endereço em A e JA do início de um número de linha fictício n + 1

  %vetor AA JA IA

  Este formato é provavelmente o mais popular para armazenar matrizes escassas gerais.
  Ele é chamado de Compressed Sparse Row (CSR) formato. Este esquema é preferido sobre o esquema de coordenadas porque é muitas vezes mais útil para executar cálculos típicos.
  
   Por outro lado, o esquema de coordenadas é vantajoso pela sua simplicidade e flexibilidade.
  É freqüentemente usado como um formato de "entrada" em pacotes de software de matriz esparsa.
  
  Há um número de variações para o formato de Linha Esparsa Comprimida.
   A variação mais óbvia é armazenar as colunas em vez das linhas.
   O esquema correspondente é conhecido como o esquema Compressed Sparse Column (CSC).
  Outra variação comum explora o fato de que os elementos diagonais de muitas matrizes são geralmente não-zero e / ou que são acessados com mais freqüência do que o resto dos elementos.
  
  Como resultado, eles podem ser armazenados separadamente.
  O formato Modified Sparse Row (MSR) tem apenas duas matrizes: uma matriz de matriz real AA e uma matriz de número inteiro JA.
  As primeiras n posições em AA contêm os elementos diagonais da matriz em ordem.
  A posição não utilizada n + 1 da matriz AA pode, por vezes, conter alguma informação relativa à matriz.
  
  Começando na posição n + 2, as entradas não nulas de AA, excluindo os seus elementos diagonais, são armazenadas por linha.
   Para cada elemento AA (k), o inteiro JA (k) representa seu índice de coluna na matriz.
    As n + 1 primeiras posições de JA contêm o ponteiro para o início de cada linha em AA e JA.
   Assim, para o exemplo acima, as duas matrizes serão as seguintes:

   %vertor AA e JA

   A estrela indica um local não utilizado. Observe que JA (n) = JA (n + 1) = 14, indicando que a última linha é uma linha zero, uma vez que o elemento diagonal foi removido.
   
   As matrizes estruturadas diagonalmente são matrizes cujos elementos diferentes de zero estão localizados ao longo de um pequeno número de diagonais.
     Essas diagonais podem ser armazenadas em uma matriz retangular DIAG (1: n, 1: Nd), onde Nd é o número de diagonais.
     As deslocações de cada uma das diagonais em relação à diagonal principal devem ser conhecidas.
     Estes serão armazenados em uma matriz IOFF (1: Nd).
      Assim, o elemento a i, i + ioff (j) da matriz original está localizado na posição (i, j) da matriz DIAG, isto é,
      %DIAG
    
    A ordem em que as diagonais são armazenadas nas colunas de DIAG é geralmente sem importância, embora, se várias operações forem realizadas com a diagonal principal, armazená-la na primeira coluna pode ser ligeiramente vantajosa. Observe também que todas as diagonais, exceto a diagonal principal, têm menos de n elementos, portanto, há posições no DIAG que não serão usadas.
    
 %matriz exemplo 3.8
 %diag IOFF

 Um esquema mais geral que é popular em máquinas de vetores é o chamado formato Ellpack-Itpack.
   A suposição neste esquema é que há no máximo Nd elementos não nulos por linha, onde Nd é pequeno.
   Em seguida, duas matrizes retangulares de dimensão n × Nd cada são necessárias (um real e um inteiro).
   O primeiro, COEF, é semelhante ao DIAG e contém os elementos não nulos de A.
 Os elementos não nulos de cada linha da matriz podem ser armazenados em uma linha da matriz COEF (1: n, 1: Nd), completando a linha por zeros conforme necessário.
 Juntamente com o COEF, deve ser armazenada uma matriz de inteiros JCOEF (1: n, 1: Nd) que contém as posições das colunas de cada entrada no COEF.

 %exemplo 3.9


 Um determinado número de coluna deve ser escolhido para cada um dos elementos zero que devem ser adicionados para preencher as linhas mais curtas de A, isto é, as linhas 1, 4 e 5.
 Neste exemplo, esses inteiros são selecionados para serem iguais aos números de linha, como pode ser visto na matriz JCOEF.
 Isso é um pouco arbitrário e, na verdade, qualquer número inteiro entre 1 e n seria aceitavel.
 No entanto, pode haver boas razões para não inserir as mesmas integers muitas vezes, isto é, um número constante, para considerações de desempenho.

    \section{3.5}
     O produto matriz por vetor é uma operação importante que é necessária na maioria dos algoritmos de solução iterativa para resolver sistemas lineares esparsos. Esta seção mostra como elas podem ser implementadas para um pequeno subconjunto dos esquemas de armazenamento considerados anteriormente. O seguinte segmento FORTRAN 90 mostra o loop principal da operação matriz por vetor para as matrizes armazenadas no formato armazenado Compressed Sparse Row.
     %codigo fortran 1
     
    \par  codigo fortran 1
     
     Observe que cada iteração do loop calcula um componente diferente do vetor resultante. Isso é vantajoso porque cada um desses componentes pode ser computado de forma independente. Se a matriz for armazenada por colunas, então, o seguinte código pode ser usado em vez disso:
     
     %codigo fortran 2
     
     \par codigo fortran 2
     
     
     Em cada iteração do loop, um múltiplo da coluna j-ésima é adicionado ao resultado, que é supostamente inicialmente definido como zero. Observe agora que o loop externo não é mais paralelizado. Uma alternativa para melhorar a paralelização é tentar dividir a operação do vetor em cada loop interno. O loop interno tem poucas operações, em geral, então é improvável que seja uma abordagem de som. Esta comparação demonstra que as estruturas de dados podem ter que mudar para melhorar o desempenho ao lidar com computadores de alto desempenho. Agora considere o produto matriz por vetor no armazenamento diagonal.
     %codigo fortran 3
     
     \par codigo fortran 3
     
     
     Aqui, cada uma das diagonais é multiplicada pelo vetor x e o resultado adicionado ao vetor y. Reconhece-se novamente que o vetor y foi preenchido com zeros no início do loop. Do ponto de vista da paralelização e / ou da vectorização, o código acima é provavelmente o melhor para usar. Por outro lado, não é suficientemente geral. Resolver um sistema triangular inferior ou superior é outro "kernel" importante em cálculos de matriz escassa. O seguinte segmento de código mostra uma roda simples para resolver um sistema triangular inferior da unidade Lx = y para o formato de armazenamento CSR.
     %codigo fortran 4,
     
     \par codigo fortran 4
     
     
     Em cada etapa, o produto interno da solução atual x com a i-ésima linha é calculado e subtraído de y (i). Isso dá o valor de x (i). A função dotproduct calcula o produto ponto de dois vetores arbitrários u (k1: k2) e v (k1: k2). O vetor AL (K1: K2) é a i-ésima linha da matriz L em formato esparso e X (JAL (K1: K2)) é o vetor dos componentes de X reunidos em um vetor curto que é consistente com a coluna Índices dos elementos na linha AL (K1: K2).
     
    %----------------------------------------------------------------------------
\section{}
    \printbibliography
   










 \end{document}
 
